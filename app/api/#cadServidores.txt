const moment = require('moment')
const randomstring = require("randomstring")
const { dbPrefix } = require("../.env")

module.exports = app => {
    const { existsOrError, notExistsOrError, isMatchOrError, noAccessMsg } = app.api.validation
    const { mailyCliSender } = app.api.mailerCli
    const tabela = 'cad_servidores'
    const STATUS_ACTIVE = 10
    const STATUS_DELETE = 99

    const save = async (req, res) => {
        let user = req.user
        const uParams = await app.db('users').where({ id: user.id }).first();
        const body = { ...req.body }
        try {
            // Alçada para edição
            if (body.id)
                isMatchOrError(uParams && uParams.financeiro >= 3, `${noAccessMsg} "Edição de evento financeiro"`)
            // Alçada para inclusão
            else isMatchOrError(uParams && uParams.financeiro >= 2, `${noAccessMsg} "Inclusão de evento financeiro"`)
        } catch (error) {
            app.api.logger.logError({ log: { line: `Error in file: ${__filename}.${__function} ${error}`, sConsole: true } })
            return res.status(401).send(error)
        }
        const tabelaDomain = `${dbPrefix}_${user.cliente}_${user.dominio}.${tabela}`
        if (req.params.id) body.id = req.params.id

        try {
            existsOrError(body.foto64, 'Foto não informada')
            existsOrError(body.url_foto, 'url foto não informado')
            existsOrError(body.matricula, 'Matricula não informada')
            existsOrError(body.nome, 'Nome não informado')
            existsOrError(body.cpf, 'CPF não informado')
            existsOrError(body.rg, 'RG não informado')
            existsOrError(body.rg_emissor, 'RG Emissor não informado')
            existsOrError(body.rg_uf, 'RG UF não informado')
            existsOrError(body.rg_d, 'RG Emissão não informado')
            existsOrError(body.pispasep, 'PIS não informado')
            existsOrError(body.pispasep_d, 'PIS Emissão não informado')
            existsOrError(body.titulo, 'Titulo não informada')
            existsOrError(body.titulosecao, 'Titulo Sessão não informado')
            existsOrError(body.titulozona, 'Titulo Zona não informado')
            existsOrError(body.ctps, 'CTPS não informado')
            existsOrError(body.ctps_serie, 'CTPS Serie não informado')
            existsOrError(body.ctps_uf, 'CTPS UF não informado')
            existsOrError(body.ctps_d, 'CTPS Emissão não informado')
            existsOrError(body.nascimento_d, 'Data Nascimento não informada')
            existsOrError(body.pai, 'Pai não informado')
            existsOrError(body.mae, 'Mãe não informada')
            existsOrError(body.cep, 'Cep não informado')
            existsOrError(body.logradouro, 'Logradouro não informado')
            existsOrError(body.numero, 'Número não informado')
            existsOrError(body.complemento, 'Complemento não informado')
            existsOrError(body.bairro, 'Bairro não informado')
            existsOrError(body.cidade, 'Cidade não informada')
            existsOrError(body.uf, 'Estado não informado')
            existsOrError(body.naturalidade, 'Naturalidade não informado')
            existsOrError(body.naturalidade_uf, 'Naturalidade UF não informado')
            existsOrError(body.telefone, 'Telefone não informado')
            existsOrError(body.celular, 'Estado não informado')
            existsOrError(body.email, 'Email não informado')
            existsOrError(body.idbanco, 'Banco não informado')
            existsOrError(body.banco_agencia, 'Agência não informado')
            existsOrError(body.banco_agencia_digito, 'Agência Digito não informado')
            existsOrError(body.banco_conta, 'Conta não informado')
            existsOrError(body.banco_conta_digito, 'Conta Digito não informado')
            existsOrError(body.banco_operacao, 'Conta Operação não informado')
            existsOrError(body.nacionalidade, 'Nacionalidade não informado')
            existsOrError(body.sexo, 'Seco não informado')
            existsOrError(body.raca, 'Raça não informado')
            existsOrError(body.estado_civil, 'Estado Civil não informado')
            existsOrError(body.tipodeficiencia, 'Deficiência não informado')
            existsOrError(body.d_admissao, 'Data Admissão não informado')
        } catch (error) {
            app.api.logger.logError({ log: { line: `Error in file: ${__filename}.${__function} ${error}`, sConsole: true } })
            return res.status(400).send(error)
        }

        if (body.id) {
            // Variáveis da edição de um registro
            // registrar o evento na tabela de eventos
            const { createEventUpd } = app.api.sisEvents
            const evento = await createEventUpd({
                "notTo": ['created_at', 'evento', 'updated_at'],
                "last": await app.db(tabelaDomain).where({ id: body.id }).first(),
                "next": body,
                "request": req,
                "evento": {
                    "evento": `Alteração de base de evento financeiro`,
                    "tabela_bd": tabela,
                }
            })

            body.evento = evento
            body.updated_at = new Date()
            const rowsUpdated = await app.db(tabelaDomain)
                .update(body)
                .where({ id: body.id })
                .then((ret) => {
                    return res.status(200).send(body)
                })
                .catch(error => {
                    app.api.logger.logError({ log: { line: `Error in file: ${__filename} (${__function}). Error: ${error}`, sConsole: true } })
                    return res.status(500).send(error)
                })
            existsOrError(rowsUpdated, 'Evento financeiro não foi encontrado')
        } else {
            // Criação de um novo registro
            const nextEventID = await app.db('sis_events').select(app.db.raw('count(*) as count')).first()

            body.evento = nextEventID.count + 1
            // Variáveis da criação de um novo registro
            body.status = STATUS_ACTIVE
            body.dominio = user.dominio
            body.created_at = new Date()

            app.db(tabelaDomain)
                .insert(body)
                .then(ret => {
                    body.id = ret[0]
                    // registrar o evento na tabela de eventos
                    const { createEventIns } = app.api.sisEvents
                    createEventIns({
                        "notTo": ['created_at', 'evento', 'updated_at'],
                        "next": body,
                        "request": req,
                        "evento": {
                            "evento": `Novo evento financeiro`,
                            "tabela_bd": tabela,
                        }
                    })
                    return res.json({ id: body.id })
                })
                .catch(error => {
                    app.api.logger.logError({ log: { line: `Error in file: ${__filename} (${__function}). Error: ${error}`, sConsole: true } })
                    return res.status(500).send(error)
                })
        }
    }

    const limit = 20 // usado para paginação
    const get = async (req, res) => {
        const uParams = await app.db('users').where({ id: req.user.id }).first();
        try {
            // Alçada para exibição
            isMatchOrError(uParams && uParams.financeiro >= 1, `${noAccessMsg} "Exibição dos Servidores"`)
        } catch (error) {
            return res.status(401).send(error)
        }
        const body = { ...req.body }
        const page = req.query.page || 1
        const tabelaDomain = `${dbPrefix}_${uParams.cliente}_${uParams.dominio}.${tabela}`

        let sql = app.db(tabelaDomain)
            .select(app.db.raw('count(*) as count'))
            .andWhere(app.db.raw(`${tabelaDomain}.status = ${STATUS_ACTIVE}`))
        const result = await app.db.raw(sql.toString())
        const count = parseInt(result[0][0].count) || 0

        let ret = app.db(tabelaDomain)
            .andWhere(app.db.raw(`${tabelaDomain}.status = ${STATUS_ACTIVE}`))
            .limit(limit).offset(page * limit - limit)
            .orderBy('nome')
            .then(body => {
                return res.json({ data: body, count, limit })
            })
            .catch(error => {
                app.api.logger.logError({ log: { line: `Error in file: ${__filename} (${__function}). Error: ${error}`, sConsole: true } })
                return res.status(500).send(error)
            })
    }

    const getById = async (req, res) => {
        let user = req.user
        const uParams = await app.db('users').where({ id: user.id }).first();
        try {
            // Alçada para exibição
            isMatchOrError(uParams && (uParams.financeiro >= 1 || uParams.financeiro >= 1), `${noAccessMsg} "Exibição de evento financeiro"`)
        } catch (error) {
            app.api.logger.logError({ log: { line: `Error in file: ${__filename}.${__function} ${error}`, sConsole: true } })
            return res.status(401).send(error)
        }
        const tabelaDomain = `${dbPrefix}_${uParams.cliente}_${uParams.dominio}.${tabela}`

        app.db(`${tabelaDomain}`)
            .where({ status: STATUS_ACTIVE, id: req.params.id })
            .first().then(body => {
                return res.json(body)
            })
            .catch(error => {
                app.api.logger.logError({ log: { line: `Error in file: ${__filename} (${__function}). Error: ${error}`, sConsole: true } })
                return res.status(500).send(error)
            })
    }

    const remove = async (req, res) => {
        let user = req.user
        const uParams = await app.db('users').where({ id: user.id }).first();
        try {
            // Alçada para exclusão
            isMatchOrError(uParams && uParams.financeiro >= 4, `${noAccessMsg} "Exclusão de evento financeiro"`)
        } catch (error) {
            app.api.logger.logError({ log: { line: `Error in file: ${__filename}.${__function} ${error}`, sConsole: true } })
            return res.status(401).send(error)
        }
        const tabelaDomain = `${dbPrefix}_${uParams.cliente}_${uParams.dominio}.${tabela}`
        try {
            const { createEventRemove } = app.api.sisEvents
            const evento = await createEventRemove({
                "last": await app.db(tabelaDomain)
                    .where({ id: req.params.id }).first(),
                "request": req,
                "evento": {
                    "classevento": "Remove",
                    "evento": `Exclusão de registro`,
                    "tabela_bd": tabela,
                }
            })
            const rowsUpdated = await app.db(tabelaDomain)
            .update({
                status: STATUS_DELETE,
                evento: evento
            })
            .where({ id: req.params.id })
            existsOrError(rowsUpdated, 'Registro não foi encontrado')

            res.status(204).send()
        } catch (error) {
            app.api.logger.logError({ log: { line: `Error in file: ${__filename}.${__function} ${error}`, sConsole: true } })
            res.status(500).send(error)
        }
    }

    return { get, getById, save, remove }
}